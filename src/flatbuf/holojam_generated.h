// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_HOLOJAM_HOLOJAM_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_HOLOJAM_HOLOJAM_PROTOCOL_H_

#include <flatbuffers/flatbuffers.h>

namespace Holojam {
namespace Protocol {

struct Nugget;

struct Flake;

struct Vector3;

struct Vector4;

enum NuggetType {
  NuggetType_UPDATE = 0,
  NuggetType_EVENT = 1,
  NuggetType_MIN = NuggetType_UPDATE,
  NuggetType_MAX = NuggetType_EVENT
};

inline const char **EnumNamesNuggetType() {
  static const char *names[] = {
    "UPDATE",
    "EVENT",
    nullptr
  };
  return names;
}

inline const char *EnumNameNuggetType(NuggetType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesNuggetType()[index];
}

MANUALLY_ALIGNED_STRUCT(4) Vector3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vector3() {
    memset(this, 0, sizeof(Vector3));
  }
  Vector3(const Vector3 &_o) {
    memcpy(this, &_o, sizeof(Vector3));
  }
  Vector3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
STRUCT_END(Vector3, 12);

MANUALLY_ALIGNED_STRUCT(4) Vector4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vector4() {
    memset(this, 0, sizeof(Vector4));
  }
  Vector4(const Vector4 &_o) {
    memcpy(this, &_o, sizeof(Vector4));
  }
  Vector4(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
STRUCT_END(Vector4, 16);

struct Nugget FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SCOPE = 4,
    VT_ORIGIN = 6,
    VT_TYPE = 8,
    VT_FLAKES = 10
  };
  const flatbuffers::String *scope() const {
    return GetPointer<const flatbuffers::String *>(VT_SCOPE);
  }
  const flatbuffers::String *origin() const {
    return GetPointer<const flatbuffers::String *>(VT_ORIGIN);
  }
  NuggetType type() const {
    return static_cast<NuggetType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<Flake>> *flakes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Flake>> *>(VT_FLAKES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SCOPE) &&
           verifier.Verify(scope()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ORIGIN) &&
           verifier.Verify(origin()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_FLAKES) &&
           verifier.Verify(flakes()) &&
           verifier.VerifyVectorOfTables(flakes()) &&
           verifier.EndTable();
  }
};

struct NuggetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scope(flatbuffers::Offset<flatbuffers::String> scope) {
    fbb_.AddOffset(Nugget::VT_SCOPE, scope);
  }
  void add_origin(flatbuffers::Offset<flatbuffers::String> origin) {
    fbb_.AddOffset(Nugget::VT_ORIGIN, origin);
  }
  void add_type(NuggetType type) {
    fbb_.AddElement<int8_t>(Nugget::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_flakes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Flake>>> flakes) {
    fbb_.AddOffset(Nugget::VT_FLAKES, flakes);
  }
  NuggetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NuggetBuilder &operator=(const NuggetBuilder &);
  flatbuffers::Offset<Nugget> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Nugget>(end);
    fbb_.Required(o, Nugget::VT_FLAKES);
    return o;
  }
};

inline flatbuffers::Offset<Nugget> CreateNugget(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> scope = 0,
    flatbuffers::Offset<flatbuffers::String> origin = 0,
    NuggetType type = NuggetType_UPDATE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Flake>>> flakes = 0) {
  NuggetBuilder builder_(_fbb);
  builder_.add_flakes(flakes);
  builder_.add_origin(origin);
  builder_.add_scope(scope);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Nugget> CreateNuggetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *scope = nullptr,
    const char *origin = nullptr,
    NuggetType type = NuggetType_UPDATE,
    const std::vector<flatbuffers::Offset<Flake>> *flakes = nullptr) {
  return Holojam::Protocol::CreateNugget(
      _fbb,
      scope ? _fbb.CreateString(scope) : 0,
      origin ? _fbb.CreateString(origin) : 0,
      type,
      flakes ? _fbb.CreateVector<flatbuffers::Offset<Flake>>(*flakes) : 0);
}

struct Flake FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LABEL = 4,
    VT_VECTOR3S = 6,
    VT_VECTOR4S = 8,
    VT_FLOATS = 10,
    VT_INTS = 12,
    VT_BYTES = 14,
    VT_TEXT = 16
  };
  const flatbuffers::String *label() const {
    return GetPointer<const flatbuffers::String *>(VT_LABEL);
  }
  const flatbuffers::Vector<const Vector3 *> *vector3s() const {
    return GetPointer<const flatbuffers::Vector<const Vector3 *> *>(VT_VECTOR3S);
  }
  const flatbuffers::Vector<const Vector4 *> *vector4s() const {
    return GetPointer<const flatbuffers::Vector<const Vector4 *> *>(VT_VECTOR4S);
  }
  const flatbuffers::Vector<float> *floats() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_FLOATS);
  }
  const flatbuffers::Vector<int32_t> *ints() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INTS);
  }
  const flatbuffers::Vector<uint8_t> *bytes() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BYTES);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_LABEL) &&
           verifier.Verify(label()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VECTOR3S) &&
           verifier.Verify(vector3s()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VECTOR4S) &&
           verifier.Verify(vector4s()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FLOATS) &&
           verifier.Verify(floats()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_INTS) &&
           verifier.Verify(ints()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BYTES) &&
           verifier.Verify(bytes()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TEXT) &&
           verifier.Verify(text()) &&
           verifier.EndTable();
  }
};

struct FlakeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_label(flatbuffers::Offset<flatbuffers::String> label) {
    fbb_.AddOffset(Flake::VT_LABEL, label);
  }
  void add_vector3s(flatbuffers::Offset<flatbuffers::Vector<const Vector3 *>> vector3s) {
    fbb_.AddOffset(Flake::VT_VECTOR3S, vector3s);
  }
  void add_vector4s(flatbuffers::Offset<flatbuffers::Vector<const Vector4 *>> vector4s) {
    fbb_.AddOffset(Flake::VT_VECTOR4S, vector4s);
  }
  void add_floats(flatbuffers::Offset<flatbuffers::Vector<float>> floats) {
    fbb_.AddOffset(Flake::VT_FLOATS, floats);
  }
  void add_ints(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ints) {
    fbb_.AddOffset(Flake::VT_INTS, ints);
  }
  void add_bytes(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bytes) {
    fbb_.AddOffset(Flake::VT_BYTES, bytes);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(Flake::VT_TEXT, text);
  }
  FlakeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FlakeBuilder &operator=(const FlakeBuilder &);
  flatbuffers::Offset<Flake> Finish() {
    const auto end = fbb_.EndTable(start_, 7);
    auto o = flatbuffers::Offset<Flake>(end);
    fbb_.Required(o, Flake::VT_LABEL);
    return o;
  }
};

inline flatbuffers::Offset<Flake> CreateFlake(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> label = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Vector3 *>> vector3s = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Vector4 *>> vector4s = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> floats = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ints = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bytes = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0) {
  FlakeBuilder builder_(_fbb);
  builder_.add_text(text);
  builder_.add_bytes(bytes);
  builder_.add_ints(ints);
  builder_.add_floats(floats);
  builder_.add_vector4s(vector4s);
  builder_.add_vector3s(vector3s);
  builder_.add_label(label);
  return builder_.Finish();
}

inline flatbuffers::Offset<Flake> CreateFlakeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *label = nullptr,
    const std::vector<const Vector3 *> *vector3s = nullptr,
    const std::vector<const Vector4 *> *vector4s = nullptr,
    const std::vector<float> *floats = nullptr,
    const std::vector<int32_t> *ints = nullptr,
    const std::vector<uint8_t> *bytes = nullptr,
    const char *text = nullptr) {
  return Holojam::Protocol::CreateFlake(
      _fbb,
      label ? _fbb.CreateString(label) : 0,
      vector3s ? _fbb.CreateVector<const Vector3 *>(*vector3s) : 0,
      vector4s ? _fbb.CreateVector<const Vector4 *>(*vector4s) : 0,
      floats ? _fbb.CreateVector<float>(*floats) : 0,
      ints ? _fbb.CreateVector<int32_t>(*ints) : 0,
      bytes ? _fbb.CreateVector<uint8_t>(*bytes) : 0,
      text ? _fbb.CreateString(text) : 0);
}

inline const Holojam::Protocol::Nugget *GetNugget(const void *buf) {
  return flatbuffers::GetRoot<Holojam::Protocol::Nugget>(buf);
}

inline bool VerifyNuggetBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Holojam::Protocol::Nugget>(nullptr);
}

inline void FinishNuggetBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Holojam::Protocol::Nugget> root) {
  fbb.Finish(root);
}

}  // namespace Protocol
}  // namespace Holojam

#endif  // FLATBUFFERS_GENERATED_HOLOJAM_HOLOJAM_PROTOCOL_H_
